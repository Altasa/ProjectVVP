from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from proreceip import findreceip
from random import randint
from time import sleep
import proreceip

CHOOSING_CATEGORY, CATEGORY, COOKING = range(0, 3)

buttons = [
    ["–°–ª—É—á–∞–π–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç", "–°–æ—É—Å—ã", "–ë—É–ª—å–æ–Ω—ã –∏ —Å—É–ø—ã", "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞",
    "–°–∞–ª–∞—Ç—ã", "–ó–∞–∫—É—Å–∫–∏", "–í—ã–ø–µ—á–∫–∞", "–î–µ—Å–µ—Ä—Ç—ã"],

    ["–î–æ–º–∞—à–Ω–∏–π –º–∞–π–æ–Ω–µ–∑", "–ü–æ–¥–ª–∏–≤–∞", "–°–∞–ª–∞—Ç–Ω–∞—è –∑–∞–ø—Ä–∞–≤–∫–∞", "–°–æ—É—Å-–¥–∏–ø", "–°–ª–∞–¥–∫–∏–π —Å–æ—É—Å",
    "–Ø–≥–æ–¥–Ω—ã–π —Å–æ—É—Å", "–°–æ—É—Å –∫ –º—è—Å—É", "–°–æ—É—Å –∫ –ø—Ç–∏—Ü–µ", "–°–æ—É—Å –∫ —Ä—ã–±–µ", "–î—Ä—É–≥–∏–µ —Å–æ—É—Å—ã"],

    ["–ë—É–ª—å–æ–Ω—ã", "–ö—É—Ä–∏–Ω—ã–π –±—É–ª—å–æ–Ω", "–ú—è—Å–Ω–æ–π –±—É–ª—å–æ–Ω", "–û–≤–æ—â–Ω–æ–π –±—É–ª—å–æ–Ω", "–†—ã–±–Ω—ã–π –±—É–ª—å–æ–Ω",
    "–ì–æ—Ä—è—á–∏–µ —Å—É–ø—ã", "–ú–æ–ª–æ—á–Ω—ã–π —Å—É–ø", "–†—ã–±–Ω—ã–π —Å—É–ø", "–ë–æ—Ä—â", "–û–∫—Ä–æ—à–∫–∞", "–†–∞—Å—Å–æ–ª—å–Ω–∏–∫",
    "–°–≤–µ–∫–æ–ª—å–Ω–∏–∫", "–°–æ–ª—è–Ω–∫–∞", "–°—É–ø-–ª–∞–ø—à–∞", "–°—É–ø-–ø—é—Ä–µ", "–î—Ä—É–≥–∏–µ —Å—É–ø—ã"],

    ["–ë–ª—é–¥–∞ –∏–∑ –º—è—Å–∞", "–ë–ª—é–¥–∞ –∏–∑ –ø—Ç–∏—Ü—ã", "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞ –∏–∑ –±–∞—Ä–∞–Ω–∏–Ω—ã", "–ë–ª—é–¥–∞ –∏–∑ —Ä—ã–±—ã –∏ –º–æ—Ä–µ–ø—Ä–æ–¥—É–∫—Ç–æ–≤", "–ë–ª—é–¥–∞ –∏–∑ —Ñ–∞—Ä—à–∞", "–ë–ª—é–¥–∞ –∏–∑ –∫—Ä—É–ø",
    "–ë–ª—é–¥–∞ –∏–∑ –æ–≤–æ—â–µ–π, –≥—Ä–∏–±–æ–≤, –±–æ–±–æ–≤—ã—Ö", "–ë–ª—é–¥–∞ –∏–∑ —è–∏—Ü", "–ë–ª—é–¥–∞ –Ω–∞ –≥—Ä–∏–ª–µ", "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞ –≤ –≥–æ—Ä—à–æ—á–∫–∞—Ö", "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞ –≤ –∫–∞–∑–∞–Ω–µ",
    "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞ –≤ –º–∏–∫—Ä–æ–≤–æ–ª–Ω–æ–≤–∫–µ", "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞ –∏–∑ –±–æ–±–æ–≤—ã—Ö", "–í–∞—Ä–µ–Ω–∏–∫–∏", "–ì–∞—Ä–Ω–∏—Ä", "–ì–∞—Ä–Ω–∏—Ä –∏–∑ –∫—Ä—É–ø"],

    ["–†—ã–±–Ω—ã–µ —Å–∞–ª–∞—Ç—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –º–æ—Ä–µ–ø—Ä–æ–¥—É–∫—Ç–æ–≤", "–°–∞–ª–∞—Ç—ã –∏–∑ –±–∞—Ä–∞–Ω–∏–Ω—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –≤–µ—Ç—á–∏–Ω—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –≥–æ–≤—è–¥–∏–Ω—ã",
    "–°–∞–ª–∞—Ç—ã –∏–∑ –∏–Ω–¥–µ–π–∫–∏", "–°–∞–ª–∞—Ç—ã –∏–∑ –∫—É—Ä–∏—Ü—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –ø—Ç–∏—Ü—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –º—è—Å–∞", "–°–∞–ª–∞—Ç—ã –∏–∑ —Å–≤–∏–Ω–∏–Ω—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –º—è—Å–Ω—ã—Ö —Å—É–±–ø—Ä–æ–¥—É–∫—Ç–æ–≤",
    "–°–∞–ª–∞—Ç—ã –∏–∑ —Å—É–±–ø—Ä–æ–¥—É–∫—Ç–æ–≤ –ø—Ç–∏—Ü—ã", "–°–∞–ª–∞—Ç—ã –∏–∑ –æ–≤–æ—â–µ–π, –≥—Ä–∏–±–æ–≤, —Å—ã—Ä–∞", "–°–∞–ª–∞—Ç—ã –∏–∑ –æ–≤–æ—â–µ–π",
    "–°–∞–ª–∞—Ç—ã –∏–∑ –±–æ–±–æ–≤—ã—Ö", "–°–∞–ª–∞—Ç—ã –∏–∑ —Ä—ã–±—ã –∏ –º–æ—Ä–µ–ø—Ä–æ–¥—É–∫—Ç–æ–≤"],

    ["–ë—É—Ç–µ—Ä–±—Ä–æ–¥—ã", "–ì–æ—Ä—è—á–∏–µ –∑–∞–∫—É—Å–∫–∏", "–ì—Ä–∏–±–Ω—ã–µ –∑–∞–∫—É—Å–æ—á–Ω—ã–µ —Ç–æ—Ä—Ç—ã", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ –º—è—Å–∞", "–ó–∞–∫—Ä—ã—Ç—ã–π –±—É—Ç–µ—Ä–±—Ä–æ–¥",
    "–ó–∞–∫—É—Å–∫–∏ –∏–∑ —Ä—ã–±—ã –∏ –º–æ—Ä–µ–ø—Ä–æ–¥—É–∫—Ç–æ–≤", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ —Å—É–±–ø—Ä–æ–¥—É–∫—Ç–æ–≤", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ –æ–≤–æ—â–µ–π", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ —Å—ã—Ä–∞", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ —è–∏—Ü",
    "–ó–∞–∫—É—Å–∫–∏ —Å –≥—Ä–∏–±–∞–º–∏", "–ó–∞–∫—É—Å–∫–∏ —Å –∫–æ–ª–±–∞—Å–Ω—ã–º–∏ –∏–∑–¥–µ–ª–∏—è–º–∏", "–ó–∞–∫—É—Å–∫–∏ —Å –∫–æ–ø—á–µ–Ω–æ—Å—Ç—è–º–∏", "–ó–∞–∫—É—Å–æ—á–Ω—ã–µ –∫–µ–∫—Å—ã, –º–∞—Ñ—Ñ–∏–Ω—ã",
    "–ó–∞–∫—É—Å–æ—á–Ω—ã–µ —Ä—É–ª–µ—Ç—ã", "–ó–∞–∫—É—Å–æ—á–Ω—ã–µ —Ç–æ—Ä—Ç—ã"],

    ["–ë–∏—Å–∫–≤–∏—Ç–Ω–æ–µ —Ç–µ—Å—Ç–æ", "–ó–∞–≤–∞—Ä–Ω–æ–µ —Ç–µ—Å—Ç–æ", "–î—Ä–æ–∂–∂–µ–≤–æ–µ —Ç–µ—Å—Ç–æ", "–ë–ª–∏–Ω—ã", "–ë—É–ª–æ—á–∫–∏",
    "–ë–ª–∏–Ω—ã, –æ–ª–∞–¥—å–∏, —Å—ã—Ä–Ω–∏–∫–∏", "–î–æ–º–∞—à–Ω–∏–π —Ö–ª–µ–±", "–ó–∞–∫—É—Å–∫–∏ –∏–∑ –±–ª–∏–Ω–æ–≤", "–ö–µ–∫—Å—ã", "–ö—É–ª–∏—á–∏",
    "–õ–∞–≤–∞—à", "–õ–µ–ø–µ—à–∫–∏", "–û–ª–∞–¥—å–∏", "–ù–∞—á–∏–Ω–∫–∞ –¥–ª—è –±–ª–∏–Ω–æ–≤", "–ò–∑–¥–µ–ª–∏—è –∏–∑ —Ç–µ—Å—Ç–∞", "–î—Ä—É–≥–∏–µ –∏–∑–¥–µ–ª–∏—è"],

    ["–ë–µ–∑–µ", "–ñ–µ–ª–µ", "–ë–∏—Å–∫–≤–∏—Ç–Ω–æ–µ –ø–µ—á–µ–Ω—å–µ", "–ë–∏—Å–∫–≤–∏—Ç–Ω—ã–π —Ç–æ—Ä—Ç", "–í–∞—Ñ–ª–∏", "–ì—Ä–µ–Ω–∫–∏",
    "–î–µ—Å–µ—Ä—Ç—ã –±–µ–∑ –≤—ã–ø–µ—á–∫–∏", "–î–µ—Å–µ—Ä—Ç–Ω—ã–µ –∫—Ä–µ–º–∞", "–ó–∞–≤–∞—Ä–Ω–æ–π —Ç–æ—Ä—Ç", "–ú–µ–¥–æ–≤—ã–π —Ç–æ—Ä—Ç",
    "–ö–æ–Ω—Ñ–µ—Ç—ã", "–ú–æ—Ä–æ–∂–µ–Ω–æ–µ", "–ú—É—Å—Å—ã", "–ú—é—Å–ª–∏", "–î—Ä—É–≥–æ–µ", "–î—Ä—É–≥–∏–µ –¥–µ—Å–µ—Ä—Ç—ã"],
]

def category_markups(category: str = "default") -> InlineKeyboardMarkup:
    def algorithm(index: int) -> list:
        category_keyboard = []
        if len(buttons[index]) % 2 == 0:
                for i in range(0, len(buttons[index]), 2):
                    category_keyboard.append([InlineKeyboardButton(buttons[index][i], callback_data = buttons[index][i]),
                                InlineKeyboardButton(buttons[index][i+1], callback_data = buttons[index][i+1])])
                if index != 0:
                    category_keyboard.append([InlineKeyboardButton("–ì–ª–∞–≤–Ω–∞—è", callback_data="Main")])
                return category_keyboard
        else:
            for i in range(0, len(buttons[index])-1, 2):
                category_keyboard.append([InlineKeyboardButton(buttons[index][i], callback_data = buttons[index][i]),
                            InlineKeyboardButton(buttons[index][i+1], callback_data = buttons[index][i+1])])
            category_keyboard.append([InlineKeyboardButton(buttons[index][len(buttons[index])-1], callback_data = buttons[index][len(buttons[index])-1])])
            if index != 0:
                category_keyboard.append([InlineKeyboardButton("–ì–ª–∞–≤–Ω–∞—è", callback_data="Main")])
            return category_keyboard
    keyboard = list()
    match category:
        case "default":
            keyboard = algorithm(0)
        case "–°–æ—É—Å—ã":
            keyboard = algorithm(1)
        case "–ë—É–ª—å–æ–Ω—ã –∏ —Å—É–ø—ã":
            keyboard = algorithm(2)
        case "–ì–æ—Ä—è—á–∏–µ –±–ª—é–¥–∞":
            keyboard = algorithm(3)
        case "–°–∞–ª–∞—Ç—ã":
            keyboard = algorithm(4)
        case "–ó–∞–∫—É—Å–∫–∏":
            keyboard = algorithm(5)
        case "–í—ã–ø–µ—á–∫–∞":
            keyboard = algorithm(6)
        case "–î–µ—Å–µ—Ä—Ç—ã":
            keyboard = algorithm(7)    
    category_markup = InlineKeyboardMarkup(keyboard)
    return category_markup

def subcategory_markups(subcategory: str) -> list:
    subcategory_keyboards = []
    for i in range(len(proreceip.subcategories[subcategory])):
        subcategory_keyboard = []
        for j in range(0,len(proreceip.subcategories[subcategory][i])):
            subcategory_keyboard.append([InlineKeyboardButton(proreceip.subcategories[subcategory][i][j],
                                                    callback_data=f"start.{subcategory}.{i}.{j}")])
        if i == 0:
            subcategory_keyboard.append([InlineKeyboardButton("–ì–ª–∞–≤–Ω–∞—è", callback_data="Main"),
                                                    InlineKeyboardButton("-->", callback_data="Next")])
        elif i == len(proreceip.subcategories[subcategory]) - 1:
            subcategory_keyboard.append([InlineKeyboardButton("<--", callback_data="Prev"),
                                                    InlineKeyboardButton("–ì–ª–∞–≤–Ω–∞—è", callback_data="Main")])
        else:
            subcategory_keyboard.append([InlineKeyboardButton("<--", callback_data="Prev"),
                                                    InlineKeyboardButton("–ì–ª–∞–≤–Ω–∞—è", callback_data="Main"),
                                                    InlineKeyboardButton("-->", callback_data="Next")])
        subcategory_keyboards.append(subcategory_keyboard)
    subcategory_markups = []
    for i in range(len(subcategory_keyboards)):
        subcategory_markups.append(InlineKeyboardMarkup(subcategory_keyboards[i]))
    return subcategory_markups

def recipe_markups(flag: str, step: int) -> list:
    keyboard = []
    match flag:
        case "start" | "start_random":
            keyboard.append([InlineKeyboardButton("–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã", callback_data = "ingredient")])
            markup = InlineKeyboardMarkup(keyboard)
            return markup
        case "ingredient" | "step":
            keyboard.append([InlineKeyboardButton(f"–ü–µ—Ä–µ–π—Ç–∏ –∫ —à–∞–≥—É {step}", callback_data = "step")])
            markup = InlineKeyboardMarkup(keyboard)
            return markup



async def default(update, _):
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup = category_markups())
    return CHOOSING_CATEGORY

async def choice(update, _):
    query = update.callback_query
    variant = query.data
    await query.answer()
    await query.edit_message_text(text = f"–í—ã –≤—ã–±—Ä–∞–ª–∏: {variant}.\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
                                    reply_markup = category_markups(variant))
    return CATEGORY

cooking_flag = ""
current_step = 1
ingredient_triggered = False
data = {}
final_message = "\n\n–ù–∞ —ç—Ç–æ–º –≤—Å—ë... –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∞–ø–ø–µ—Ç–∏—Ç–∞!"
hint = "\n\nüí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /stop —á—Ç–æ–±—ã –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞"
hint_end = "üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /begin –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞ —Ä–µ—Ü–µ–ø—Ç–æ–≤"
async def cooking(update, context):
    query = update.callback_query
    recipe = query.data.split('.')
    await query.answer()
    global active_page, active_subcategory, active_variant
    global cooking_flag, current_step, ingredient_triggered, data
    if recipe[0] == "–°–ª—É—á–∞–π–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç":
        cooking_flag = "start_random"
    else:
        cooking_flag = recipe[0]
    match cooking_flag:
        case "Main":
            active_subcategory.clear()
            active_variant = ""
            cooking_flag = ""
            current_step = 1
            active_page = 0
            ingredient_triggered = False
            data.clear()
            await query.edit_message_text(text = "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup = category_markups())
            return CHOOSING_CATEGORY
        case "Prev":
            active_page -= 1
            recipes = f"–†–µ—Ü–µ–ø—Ç—ã –≤ –¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {active_page+1} –∏–∑ {len(active_subcategory)}"
            await query.edit_message_text(text = recipes, reply_markup = active_subcategory[active_page])
            return COOKING
        case "Next":
            active_page += 1
            recipes = f"–†–µ—Ü–µ–ø—Ç—ã –≤ –¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {active_page+1} –∏–∑ {len(active_subcategory)}"
            await query.edit_message_text(text = recipes, reply_markup = active_subcategory[active_page])
            return COOKING
        case "start":
            receip = proreceip.urlreceip[recipe[1]][int(recipe[2])][int(recipe[3])]
            data = findreceip(receip)
            rm = recipe_markups(cooking_flag, current_step)
            title, description, source = data['title'].split(': '), data['description'], data['resource']
            print(title[0] + ": " + title[1] + ". –ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: " + recipe[1])
            message = title[1] + "\n\n–û–ø–∏—Å–∞–Ω–∏–µ:\n" + description + "\n\n–ò—Å—Ç–æ—á–Ω–∏–∫: " + source
            await context.bot.send_photo(chat_id = update.effective_chat.id,
                                            photo = data['image'], caption = message, reply_markup = rm)
            return COOKING
        case "start_random":
            subcat = proreceip.keys[randint(0, 331)]
            receip = proreceip.urlreceip[subcat][randint(0, 2)][randint(0, 4)]
            data = findreceip(receip)
            rm = recipe_markups(cooking_flag, current_step)
            title, description, source = data['title'].split(': '), data['description'], data['resource']
            print(title[0] + ": " + title[1] + ". –ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: " + subcat)
            message = title[1] + "\n\n–û–ø–∏—Å–∞–Ω–∏–µ:\n" + description + "\n\n–ò—Å—Ç–æ—á–Ω–∏–∫: " + source
            await context.bot.send_photo(chat_id = update.effective_chat.id,
                                            photo = data['image'], caption = message, reply_markup = rm)
            return COOKING
        case "ingredient":
            if ingredient_triggered is False:
                rm = recipe_markups(cooking_flag, current_step)
                ingredients = data['ingredients'].split("\n")
                message = "–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:\n"
                for i in range(len(ingredients)):
                    message += f"{i+1}. " + ingredients[i] + "\n"
                message += hint
                await context.bot.send_message(chat_id = update.effective_chat.id,
                                                text = message, reply_markup = rm)
                ingredient_triggered = True
                return COOKING
            return COOKING
        case "step":
            if current_step == len(data) - 5:
                step_image = data[f"step{current_step}"][0]
                step_text = f"–®–∞–≥ {current_step}\n" + data[f"step{current_step}"][1] + final_message
                await context.bot.send_photo(chat_id = update.effective_chat.id,
                                                photo = step_image, caption = step_text)
                sleep(0.5)
                await context.bot.send_message(chat_id = update.effective_chat.id,
                                                text = hint_end)
                active_subcategory.clear()
                active_variant = ""
                cooking_flag = ""
                current_step = 1
                active_page = 0
                ingredient_triggered = False
                return ConversationHandler.END
            else:
                rm = recipe_markups(cooking_flag, current_step+1)
                step_image = data[f"step{current_step}"][0]
                step_text = f"–®–∞–≥ {current_step}\n" + data[f"step{current_step}"][1]
                await context.bot.send_photo(chat_id = update.effective_chat.id,
                                                photo = step_image, caption = step_text, reply_markup = rm)
                current_step += 1
                return COOKING

active_subcategory = list()
active_page = 0
active_variant = ""
async def category(update, _) -> int:
    query = update.callback_query
    variant = query.data
    await query.answer()
    global active_page, active_subcategory, active_variant
    match variant:
        case "Main":
            await query.edit_message_text(text = "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup = category_markups())
            return CHOOSING_CATEGORY
        case _:
            active_variant = variant
            active_subcategory = subcategory_markups(variant)
            message = f"–†–µ—Ü–µ–ø—Ç—ã –≤ –¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {active_page+1} –∏–∑ {len(active_subcategory)}"
            await query.edit_message_text(text = message, reply_markup = active_subcategory[active_page])
            return COOKING

async def done(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    global active_page, active_subcategory, active_variant
    global cooking_flag, current_step, ingredient_triggered
    active_subcategory.clear()
    active_variant = ""
    cooking_flag = ""
    current_step = 1
    active_page = 0
    ingredient_triggered = False
    data.clear()
    message = "‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞ –ø—Ä–µ—Ä–≤–∞–Ω–æ\n\n" + hint_end
    await context.bot.send_message(chat_id=update.effective_chat.id, text=message)
    return ConversationHandler.END
